#!/usr/bin/env python

from StringIO import StringIO
from twisted.application import internet, service
from twisted.enterprise import adbapi
from twisted.internet import defer, protocol, reactor, threads
from twisted.mail import smtp

def equal(actual, expected):
  print 'PASS' if expected == actual else 'FAIL "%s" "%s"' % (actual, expected)

application = service.Application('test')

pool = adbapi.ConnectionPool('MySQLdb', db='cookie', user='root')

def delete():
  conn = adbapi.Connection(pool)
  trans = adbapi.Transaction(pool, conn)

  trans.execute('DELETE FROM address')
  trans.close()

message = [{
  'data': StringIO('''Received: from example.com (localhost [127.0.0.1])
  by example.com (Postfix) with ESMTPA
  for <bob@example.com>; Fri, 13 Feb 2009 15:31:30 -0800 (PST)
From: notalice@example.com

la di da
'''),
  'from': 'alice@example.com',
  'to': ['bob@example.com'] }]

def callback(result):
  def insert():
    conn = adbapi.Connection(pool)
    trans = adbapi.Transaction(pool, conn)

    trans.execute('INSERT INTO address (address, sender) VALUES (%s, %s)', ('bob@example.com', 'abc123'))
    trans.close()

  def callback(result):
    class Message:
      def __init__(self):
        self.data = []

      def eomReceived(self):
        equal("\n".join(self.data) + "\n", '''Received: from example.com (localhost [127.0.0.1])
  by example.com (Postfix) with ESMTPA
  for <bob@example.com>; Fri, 13 Feb 2009 15:31:30 -0800 (PST)
From: abc123@nottheoilrig.com

la di da
''')

        return defer.succeed(None)

      def lineReceived(self, line):
        self.data.append(line)

    class Server(smtp.ESMTP):
      def do_UNKNOWN(self, rest):
        raise Exception

      def do_XFORWARD(self, rest):
        global xforward

        xforward = rest

        self.sendCode(250, 'Ok')

      def extensions(self):
        return { 'XFORWARD': ['NAME', 'ADDR', 'PORT', 'HELO', 'PROTO', 'SOURCE'] }

      def receivedHeader(self, helo, origin, recipients):
        pass

      def validateFrom(self, helo, origin):
        equal(xforward, 'NAME=localhost ADDR=127.0.0.1 PORT=47831 HELO=example.com PROTO=ESMTP SOURCE=LOCAL')

        equal(str(origin), 'alice@example.com')

        return origin

      def validateTo(self, user):
        equal(str(user), 'bob@example.com')

        return Message

    # ESMTPFactory doesn't exist
    class ServerFactory(smtp.SMTPFactory):
      protocol = Server

    factory = ServerFactory()

    service = internet.TCPServer(1894, factory)
    service.setServiceParent(application)

    class Client(smtp.ESMTPClient):

      # Shortcut ESMTPClient.__init__(), no authentication or TLS
      def __init__(self, *args, **kw):
        self.secret = None

        return smtp.SMTPClient.__init__(self, *args, **kw)

      def esmtpState_serverConfig(self, code, resp):
        equal(resp, '''selene Hello 127.0.0.1, nice to meet you
XFORWARD NAME ADDR PORT HELO PROTO SOURCE''')

        return smtp.ESMTPClient.esmtpState_serverConfig(self, code, resp)

      def getMailData(self):
        return message[0]['data']

      def getMailFrom(self):
        return message[0]['from']

      def getMailTo(self):
        return message[0]['to']

      def smtpState_from(self, code, resp):
        self.sendLine('XFORWARD NAME=localhost ADDR=127.0.0.1 PORT=47831 HELO=example.com PROTO=ESMTP SOURCE=LOCAL')
        self._expected = xrange(0, 1000)
        self._okresponse = lambda code, resp: smtp.ESMTPClient.smtpState_from(self, code, resp)

      def smtpState_msgSent(self, code, resp):
        global message

        message = message[1:]
        if message:
          self._from = None
          self.toAddressesResult = []

          return smtp.ESMTPClient.smtpState_msgSent(self, code, resp)

        # No more messages to send
        self._disconnectFromServer()

    class ClientFactory(protocol.ClientFactory):
      protocol = Client

      def buildProtocol(self, addr):
        return self.protocol('example.com')

    factory = ClientFactory()

    service = internet.TCPClient('localhost', 1438, factory)
    service.setServiceParent(application)

    def timeout():
      reactor.stop()

    reactor.callLater(2, timeout)

  threads.deferToThreadPool(reactor, pool.threadpool, insert).addCallback(callback)

threads.deferToThreadPool(reactor, pool.threadpool, delete).addCallback(callback)
