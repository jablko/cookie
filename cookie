#!/usr/bin/env python

import functools, re, rfc5321, rfc5322, socket, sys
from random import random
from StringIO import StringIO
from twisted.enterprise import adbapi
from twisted.internet import defer, protocol, reactor, threads
from twisted.mail import smtp
from twisted.python import failure, log
from twisted.web import http

log.startLogging(sys.stdout)

def coroutine(function):
  def wrapper(*args, **kw):
    generator = function(*args, **kw)

    # TODO Tail call elimination
    def callback(result):
      try:

        # .addBoth() so as not to errback exceptions in callback to callback
        return (generator.throw(result.type, result.value, result.tb) if isinstance(result, failure.Failure) else generator.send(result)).addBoth(callback)

      except StopIteration, e:
        try:
          return e.args[0]

        except IndexError:
          pass

    try:

      # .addBoth() so as not to errback exceptions in callback to callback
      return generator.next().addBoth(callback)

    except StopIteration, e:
      try:
        return e.args[0]

      except IndexError:
        pass

  return functools.update_wrapper(wrapper, function)

class Queue:
  def __init__(self):
    self.deferred = []
    self.item = []

  def push(self, item):
    try:
      self.deferred.pop(0).callback(item)

    except IndexError:
      self.item.append(item)

    return self

  def shift(self):
    try:
      return defer.succeed(self.item.pop(0))

    except IndexError:
      deferred = defer.Deferred()
      self.deferred.append(deferred)

      return deferred

# Cache our domain
domain = socket.getfqdn()

ehlo = defer.Deferred()

class SMTPClient(smtp.ESMTPClient):

  # Shortcut ESMTPClient.__init__(), no authentication or TLS
  def __init__(self, *args, **kw):
    self.secret = None

    return smtp.SMTPClient.__init__(self, domain, *args, **kw)

  def esmtpState_serverConfig(self, *args, **kw):
    try:
      ehlo.callback(args)

    except defer.AlreadyCalledError:
      ehlo.result = args

    return smtp.ESMTPClient.esmtpState_serverConfig(self, *args, **kw)

  def getMailData(self):
    self.message.data.seek(0)

    return self.message.data

  def getMailFrom(self):
    return self.message.user.orig

  def getMailTo(self):
    return [str(self.message.user)]

  # Wait for message from client
  @coroutine
  def smtpState_from(self, code, resp):
    self.message = yield self.factory.message.shift()

    smtp.ESMTPClient.smtpState_from(self, code, resp)

  def smtpState_msgSent(self, code, resp):
    self.message.deferred.callback(None)

    self._from = None
    self.toAddressesResult = []

    return self.smtpState_from(code, resp)

class SMTPClientFactory(protocol.ClientFactory):
  protocol = SMTPClient

pool = adbapi.ConnectionPool('MySQLdb', db='cookie', user='root')

# Buffer lines to .data, call .deferred on delivery success or failure
class Message:
  def eomReceived(self):
    self.deferred = defer.Deferred()

    @coroutine
    def filter():

      # No need to compile regex, most recent patterns are cached,
      # http://docs.python.org/library/re#re.compile
      if re.match(rfc5321.timeStampLine, self.data.getvalue()):

        @coroutine
        def messageId(pattern):

          # TODO Support multiple message ids, regex currently supports only one
          match = re.search(pattern, self.data.getvalue())
          if not match:
            raise

          def select():
            conn = adbapi.Connection(pool)
            trans = adbapi.Transaction(pool, conn)

            trans.execute('SELECT sender FROM message_id WHERE message_id = %s', match.group(1))
            result = trans.fetchall()
            trans.close()

            return result

          result = yield threads.deferToThreadPool(reactor, pool.threadpool, select)

          try:
            #return result[0][0]
            raise StopIteration(result[0][0])

          except IndexError:
            raise

        try:
          sender = yield messageId(rfc5322.inReplyTo)

        except:
          try:
            sender = yield messageId(rfc5322.references)

          except:
            def select():
              conn = adbapi.Connection(pool)
              trans = adbapi.Transaction(pool, conn)

              trans.execute('SELECT sender FROM address WHERE address = %s', self.user)
              result = trans.fetchall()
              trans.close()

              return result

            result = yield threads.deferToThreadPool(reactor, pool.threadpool, select)

            try:
              sender = result[0][0]

            except IndexError:
              alphabet = '0123456789abcdefghijklmnopqrstuvwxyz'

              # Choose six letters from alphabet, at random
              letter = random()
              sender = ''
              for ignore in range(6):
                letter *= len(alphabet)
                sender += alphabet[int(letter)]
                letter -= int(letter)

              def insert():
                conn = adbapi.Connection(pool)
                trans = adbapi.Transaction(pool, conn)

                trans.execute('INSERT INTO address (address, sender) VALUES (%s, %s)', (self.user, sender))
                trans.close()

              yield threads.deferToThreadPool(reactor, pool.threadpool, insert)

        self.user.orig.local = sender
        self.user.orig.domain = 'nottheoilrig.com'

        def repl(match):
          repl = 'From:'

          # displayName
          if match.group(1):
            repl += match.group(1)

          # angleAddr
          if match.group(3):
            repl += match.group(3)

            # localPart dotAtom
            if match.group(4):
              repl += match.group(4)

            # localPart quotedString
            elif match.group(6):
              repl += match.group(6)

            repl += str(self.user.orig)

            # domain dotAtom
            if match.group(8):
              repl += match.group(8)

            # domain domainLiteral
            elif match.group(9):
              repl += match.group(9)

            repl += match.group(10)

          else:

            # localPart dotAtom
            if match.group(11):
              repl += match.group(11)

            # localPart quotedString
            elif match.group(13):
              repl += match.group(13)

            repl += str(self.user.orig)

            # domain dotAtom
            if match.group(14):
              repl += match.group(14)

            # domain domainLiteral
            elif match.group(16):
              repl += match.group(16)

          repl += '\n'

          return repl

        self.data.seek(0)
        self.data.write(re.sub(rfc5322.From, repl, self.data.getvalue(), 1))
        self.data.truncate()

        self.factory.message.push(self)

      else:
        match = re.search(rfc5322.messageId, self.data.getvalue())
        if match:
          def select():
            conn = adbapi.Connection(pool)
            trans = adbapi.Transaction(pool, conn)

            trans.execute('SELECT COUNT(*) FROM address WHERE sender = %s', self.user.dest.local)
            result = trans.fetchall()
            trans.close()

            return result

          result = yield threads.deferToThreadPool(reactor, pool.threadpool, select)
          if result[0][0]:
            def insert():
              conn = adbapi.Connection(pool)
              trans = adbapi.Transaction(pool, conn)

              trans.execute('INSERT INTO message_id (message_id, sender) VALUES (%s, %s)', (match.group(1), self.user.dest.local))
              trans.close()

            yield threads.deferToThreadPool(reactor, pool.threadpool, insert)

            self.factory.message.push(self)

          else:
            self.factory.message.push(self)

        else:
          self.factory.message.push(self)

    filter()

    return self.deferred

  def lineReceived(self, line):
    self.data.write(line + "\n")

# Ignore lines, only buffer once per message, use for multiple recipients
class NullMessage(Message):
  def lineReceived(self, line):
    pass

class SMTPServer(smtp.ESMTP):
  def connectionMade(self):
    self.factory = SMTPClientFactory()
    self.factory.message = Queue()

    reactor.connectTCP('localhost', 1894, self.factory)

    return smtp.ESMTP.connectionMade(self)

  # Override ESMTP.do_EHLO() to supress sendCode() until client replies
  @coroutine
  def do_EHLO(self, rest):
    peer = self.transport.getPeer().host
    self._helo = (rest, peer)
    self._from = None
    self._to = []

    result = yield ehlo

    self.sendCode(*result)

    #return result
    raise StopIteration(result)

  # Suppress Received header because we're a content filter
  def receivedHeader(self, helo, origin, recipients):
    pass

  # Message for first recipient
  def validateFrom(self, helo, origin):
    self.data = StringIO()
    self.message = Message()

    return origin

  # Don't yet know if we're sending (ESMTPA) or receiving (ESMTP)
  def validateTo(self, user):
    message = self.message
    message.data = self.data
    message.factory = self.factory
    message.user = user

    # NullMessage for subsequent recipients
    self.message = NullMessage()

    return lambda: message

# ESMTPFactory doesn't exist
class SMTPServerFactory(smtp.SMTPFactory):
  protocol = SMTPServer

factory = SMTPServerFactory()
reactor.listenTCP(1438, factory, interface='localhost')

class Request(http.Request):

  @coroutine
  def process(self):
    if not re.match('/' + rfc5322.addrSpec, self.path):
      self.setResponseCode(http.NOT_FOUND)

      self.finish()

    else:
      def select():
        conn = adbapi.Connection(pool)
        trans = adbapi.Transaction(pool, conn)

        trans.execute('SELECT sender FROM address WHERE address = %s', self.path[1:])
        result = trans.fetchall()
        trans.close()

        return result

      result = yield threads.deferToThreadPool(reactor, pool.threadpool, select)

      try:
        self.write(result[0][0])

      except IndexError:
        alphabet = '0123456789abcdefghijklmnopqrstuvwxyz'

        # Choose six letters from alphabet, at random
        letter = random()
        sender = ''
        for ignore in range(6):
          letter *= len(alphabet)
          sender += alphabet[int(letter)]
          letter -= int(letter)

        def insert():
          conn = adbapi.Connection(pool)
          trans = adbapi.Transaction(pool, conn)

          trans.execute('INSERT INTO address (address, sender) VALUES (%s, %s)', (self.path[1:], sender))
          trans.close()

        yield threads.deferToThreadPool(reactor, pool.threadpool, insert)

        self.write(sender)

        self.finish()

      else:
        self.finish()

class HTTPServer(http.HTTPChannel):
  requestFactory = Request

class HTTPServerFactory(http.HTTPFactory):
  protocol = HTTPServer

factory = HTTPServerFactory()
reactor.listenTCP(8743, factory, interface='localhost')

reactor.run()
