#!/usr/bin/env python

import re, rfc5321, rfc5322, socket
from random import random
from StringIO import StringIO
from twisted.application import internet, service
from twisted.enterprise import adbapi
from twisted.internet import defer, protocol, reactor, threads
from twisted.mail import smtp
from twisted.web import http

application = service.Application('cookie')

ehlo = defer.Deferred()

message = []

# Can't otherwise tell if client is running or disconnecting
running = False

class SMTPClient(smtp.ESMTPClient):

  # Shortcut ESMTPClient.__init__(), no authentication or TLS
  def __init__(self, *args, **kw):
    self.secret = None

    return smtp.SMTPClient.__init__(self, *args, **kw)

  def esmtpState_serverConfig(self, *args, **kw):
    try:
      ehlo.callback(args)

    except defer.AlreadyCalledError:
      ehlo.result = args

    return smtp.ESMTPClient.esmtpState_serverConfig(self, *args, **kw)

  def getMailData(self):
    message[0].data.seek(0)

    return message[0].data

  def getMailFrom(self):
    return message[0].user.orig

  def getMailTo(self):
    return [str(message[0].user)]

  # Wait for message from client
  def smtpState_from(self, code, resp):
    global deferred

    if message:
      return smtp.ESMTPClient.smtpState_from(self, code, resp)

    deferred = defer.Deferred()
    deferred.addCallback(lambda result: smtp.ESMTPClient.smtpState_from(self, code, resp))

  def smtpState_msgSent(self, code, resp):
    global message, running

    message[0].deferred.callback(None)

    message = message[1:]
    if message:
      self._from = None
      self.toAddressesResult = []

      return smtp.ESMTPClient.smtpState_msgSent(self, code, resp)

    # No more messages to send
    running = False

    self._disconnectFromServer()

# Cache our domain
domain = socket.getfqdn()

class SMTPClientFactory(protocol.ClientFactory):
  domain = domain
  protocol = SMTPClient

  def buildProtocol(self, addr):
    return self.protocol(self.domain)

pool = adbapi.ConnectionPool('MySQLdb', db='cookie', user='root')

# Buffer lines to .data, call .deferred on delivery success or failure
class Message:
  def eomReceived(self):
    self.deferred = defer.Deferred()

    # No need to compile regex, most recent patterns are cached,
    # http://docs.python.org/library/re#re.compile
    if re.match(rfc5321.timeStampLine, self.data.getvalue()):
      def sub(sender):
        sender += '@nottheoilrig.com'

        def repl(match):
          repl = 'From:'

          # displayName
          if match.group(1):
            repl += match.group(1)

          # angleAddr
          if match.group(3):
            repl += match.group(3)

            # localPart dotAtom
            if match.group(4):
              repl += match.group(4)

            # localPart quotedString
            elif match.group(6):
              repl += match.group(6)

            repl += sender

            # domain dotAtom
            if match.group(8):
              repl += match.group(8)

            # domain domainLiteral
            elif match.group(9):
              repl += match.group(9)

            repl += match.group(10)

          else:

            # localPart dotAtom
            if match.group(11):
              repl += match.group(11)

            # localPart quotedString
            elif match.group(13):
              repl += match.group(13)

            repl += sender

            # domain dotAtom
            if match.group(14):
              repl += match.group(14)

            # domain domainLiteral
            elif match.group(16):
              repl += match.group(16)

          repl += '\n'

          return repl

        self.data.seek(0)
        self.data.write(re.sub(rfc5322.From, repl, self.data.getvalue(), 1))
        self.data.truncate()

        message.append(self)

        deferred.callback(None)

      def messageId(pattern):

        # TODO Support multiple message ids, regex currently supports only one
        match = re.search(pattern, self.data.getvalue())
        if not match:
          raise Exception

        def select():
          conn = adbapi.Connection(pool)
          trans = adbapi.Transaction(pool, conn)

          trans.execute('SELECT sender FROM message_id WHERE message_id = %s', match.group(1))
          result = trans.fetchall()
          trans.close()

          return result

        def callback(result):
          try:
            sub(result[0][0])

          except IndexError:
            raise Exception

        return threads.deferToThreadPool(reactor, pool.threadpool, select).addCallback(callback)

      def address(result):
        def select():
          conn = adbapi.Connection(pool)
          trans = adbapi.Transaction(pool, conn)

          trans.execute('SELECT sender FROM address WHERE address = %s', self.user)
          result = trans.fetchall()
          trans.close()

          return result

        def callback(result):
          try:
            sub(result[0][0])

          except IndexError:
            alphabet = '0123456789abcdefghijklmnopqrstuvwxyz'

            letter = random()
            sender = ''
            for ignore in range(6):
              letter *= len(alphabet)
              sender += alphabet[int(letter)]
              letter -= int(letter)

            def insert():
              conn = adbapi.Connection(pool)
              trans = adbapi.Transaction(pool, conn)

              trans.execute('INSERT INTO address (address, sender) VALUES (%s, %s)', (self.user, sender))
              trans.close()

            def callback(result):
              sub(sender)

            threads.deferToThreadPool(reactor, pool.threadpool, insert).addCallback(callback)

        return threads.deferToThreadPool(reactor, pool.threadpool, select).addCallback(callback)

      # Check first for existing address associated with In-Reply-To message
      # id, then References message id, then recipient address, and finally
      # generate new address
      defer.maybeDeferred(lambda: messageId(rfc5322.inReplyTo)).addErrback(lambda result: messageId(rfc5322.references)).addErrback(address)

    else:
      match = re.search(rfc5322.messageId, self.data.getvalue())
      if match:
        def select():
          conn = adbapi.Connection(pool)
          trans = adbapi.Transaction(pool, conn)

          trans.execute('SELECT COUNT(*) FROM address WHERE sender = %s', self.user.dest.local)
          result = trans.fetchall()
          trans.close()

          return result

        def callback(result):
          if result[0][0]:
            def insert():
              conn = adbapi.Connection(pool)
              trans = adbapi.Transaction(pool, conn)

              trans.execute('INSERT INTO message_id (message_id, sender) VALUES (%s, %s)', (match.group(1), self.user.dest.local))
              trans.close()

            def callback(result):
              message.append(self)

              deferred.callback(None)

            threads.deferToThreadPool(reactor, pool.threadpool, insert).addCallback(callback)

          else:
            message.append(self)

            deferred.callback(None)

        threads.deferToThreadPool(reactor, pool.threadpool, select).addCallback(callback)

      else:
        message.append(self)

        deferred.callback(None)

    return self.deferred

  def lineReceived(self, line):
    self.data.write(line + "\n")

# Ignore lines, only buffer once per message, use for multiple recipients
class NullMessage(Message):
  def lineReceived(self, line):
    pass

class SMTPServer(smtp.ESMTP):
  def connectionMade(self):
    global clientService, running

    if not running:
      try:
        clientService.startService()

      except NameError:
        factory = SMTPClientFactory()

        clientService = internet.TCPClient('localhost', 1894, factory)
        clientService.setServiceParent(application)

      running = True

    return smtp.ESMTP.connectionMade(self)

  def do_EHLO(self, rest):
    peer = self.transport.getPeer().host
    self._helo = (rest, peer)
    self._from = None
    self._to = []

    def callback(result):
      self.sendCode(*result)

      return result

    ehlo.addCallback(callback)

  # Suppress Received header because we're a content filter
  def receivedHeader(self, helo, origin, recipients):
    pass

  # Message for first recipient
  def validateFrom(self, helo, origin):
    self.data = StringIO()
    self.message = Message()

    return origin

  def validateTo(self, user):
    message = self.message
    message.data = self.data
    message.user = user

    # NullMessage for subsequent recipients
    self.message = NullMessage()

    return lambda: message

# ESMTPFactory doesn't exist
class SMTPServerFactory(smtp.SMTPFactory):
  protocol = SMTPServer

factory = SMTPServerFactory()

serverService = internet.TCPServer(1438, factory, interface='localhost')
serverService.setServiceParent(application)

class Request(http.Request):
  def process(self):
    if not re.match('/' + rfc5322.addrSpec, self.path):
      self.setResponseCode(http.NOT_FOUND)

      self.finish()

    else:
      def select():
        conn = adbapi.Connection(pool)
        trans = adbapi.Transaction(pool, conn)

        trans.execute('SELECT sender FROM address WHERE address = %s', self.path[1:])
        result = trans.fetchall()
        trans.close()

        return result

      def callback(result):
        try:
          self.write(result[0][0])

        except IndexError:
          alphabet = '0123456789abcdefghijklmnopqrstuvwxyz'

          letter = random()
          sender = ''
          for ignore in range(6):
            letter *= len(alphabet)
            sender += alphabet[int(letter)]
            letter -= int(letter)

          def insert():
            conn = adbapi.Connection(pool)
            trans = adbapi.Transaction(pool, conn)

            trans.execute('INSERT INTO address (address, sender) VALUES (%s, %s)', (self.path[1:], sender))
            trans.close()

          def callback(result):
            self.write(sender)

            self.finish()

          threads.deferToThreadPool(reactor, pool.threadpool, insert).addCallback(callback)

        else:
          self.finish()

      threads.deferToThreadPool(reactor, pool.threadpool, select).addCallback(callback)

class HTTPServer(http.HTTPChannel):
  requestFactory = Request

class HTTPServerFactory(http.HTTPFactory):
  protocol = HTTPServer

factory = HTTPServerFactory()

serverService = internet.TCPServer(8743, factory, interface='localhost')
serverService.setServiceParent(application)
