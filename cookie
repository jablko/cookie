#!/usr/bin/env python

import re, socket
from random import random
from StringIO import StringIO
from twisted.application import internet, service
from twisted.enterprise import adbapi
from twisted.internet import defer, protocol, reactor, threads
from twisted.mail import smtp
from twisted.web import http

application = service.Application('cookie')

ehlo = defer.Deferred()

message = []

# Can't otherwise tell if client is running or disconnecting
running = False

class SMTPClient(smtp.ESMTPClient):

  # Shortcut ESMTPClient.__init__(), no authentication or TLS
  def __init__(self, *args, **kw):
    self.secret = None

    return smtp.SMTPClient.__init__(self, *args, **kw)

  def esmtpState_serverConfig(self, *args, **kw):
    try:
      ehlo.callback(args)

    except defer.AlreadyCalledError:
      ehlo.result = args

    return smtp.ESMTPClient.esmtpState_serverConfig(self, *args, **kw)

  def getMailData(self):
    message[0].data.seek(0)

    return message[0].data

  def getMailFrom(self):
    return message[0].user.orig

  def getMailTo(self):
    return [str(message[0].user)]

  # Wait for message from client
  def smtpState_from(self, code, resp):
    global deferred

    if message:
      return smtp.ESMTPClient.smtpState_from(self, code, resp)

    deferred = defer.Deferred()
    deferred.addCallback(lambda result: smtp.ESMTPClient.smtpState_from(self, code, resp))

  def smtpState_msgSent(self, code, resp):
    global message, running

    message[0].deferred.callback(None)

    message = message[1:]
    if message:
      self._from = None
      self.toAddressesResult = []

      return smtp.ESMTPClient.smtpState_msgSent(self, code, resp)

    # No more messages to send
    running = False

    self._disconnectFromServer()

# Cache our domain
domain = socket.getfqdn()

class SMTPClientFactory(protocol.ClientFactory):
  domain = domain
  protocol = SMTPClient

  def buildProtocol(self, addr):
    return self.protocol(self.domain)

ALPHA = '[A-Za-z]'

# Use local newlines
CRLF = '\n'

DIGIT = '\d'
DQUOTE = '"'
HEXDIG = '[0-9ABCDEF]'

# Visible (printing) characters
VCHAR = '[!-~]'

# White space
WSP = '[\t ]'

# Folding white space
FWS = '(?:(?:' + WSP + ')*' + CRLF + ')?(?:' + WSP + ')+'

# Printable US-ASCII characters not including "(", ")", or "\"
ctext = '[!-\'*-[\]-~]'

quotedPair = '\\\(?:' + VCHAR + '|' + WSP + ')'

# Recursive
ccontent = '(?:' + ctext + '|' + quotedPair + ')'

comment = '\((?:(?:' + FWS + ')?' + ccontent + ')*(?:' + FWS + ')?\)'
CFWS = '(?:(?:(?:' + FWS + ')?' + comment + ')+(?:' + FWS + ')?|' + FWS + ')'

# Printable US-ASCII characters not including specials.  Used for atoms
atext = '(?:[!#$%&\'*+\-/=?^_`{|}~]|' + ALPHA + '|' + DIGIT + ')'

atom = '(?:' + CFWS + ')?(?:' + atext + ')+(?:' + CFWS + ')?'

# Printable US-ASCII characters not including "\" or the quote character
qtext = '[!#-[\]-~]'

qcontent = '(?:' + qtext + '|' + quotedPair + ')'
quotedString = '(' + CFWS + ')?' + DQUOTE + '(?:(?:' + FWS + ')?' + qcontent + ')*(?:' + FWS + ')?' + DQUOTE + '(?:' + CFWS + ')?'
word = '(?:' + atom + '|' + quotedString + ')'
phrase = '(?:' + word + ')+'
displayName = phrase
dotAtomText = '(?:' + atext + ')+(?:\.(?:' + atext + ')+)*'
dotAtom = '(' + CFWS + ')?' + dotAtomText + '(' + CFWS + ')?'
localPart = '(?:' + dotAtom + '|' + quotedString + ')'

# Printable US-ASCII characters not including "[", "]", or "\"
dtext = '[!-Z^-~]'

domainLiteral = '(?:' + CFWS + ')?\[(?:(?:' + FWS + ')?' + dtext + ')*(?:' + FWS + ')?](' + CFWS + ')?'
domain = '(?:' + dotAtom + '|' + domainLiteral + ')'
addrSpec = localPart + '@' + domain
angleAddr = '((?:' + CFWS + ')?<)' + addrSpec + '(>(?:' + CFWS + ')?)'
nameAddr = '(' + displayName + ')?' + angleAddr
mailbox = '(?:' + nameAddr + '|' + addrSpec + ')'

From = 'From:' + mailbox + CRLF

idLeft = dotAtomText
noFoldLiteral = '\[(?:' + dtext + ')*]'
idRight = '(?:' + dotAtomText + '|' + noFoldLiteral + ')'
msgId = '(?:' + CFWS + ')?<(' + idLeft + '@' + idRight + ')>(?:' + CFWS + ')?'

inReplyTo = 'In-Reply-To:(?:' + msgId + ')+' + CRLF

references = 'References:(?:' + msgId + ')+' + CRLF

messageId = 'Message-ID:' + msgId + CRLF

dayOfWeek = '(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)'
day = '(?:' + FWS + ')?(?:' + DIGIT + '){1,2}' + FWS
month = '(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)'
year = FWS + '(?:' + DIGIT + '){4,}' + FWS
date = day + month + year
hour = '(?:' + DIGIT + '){2}'
minute = '(?:' + DIGIT + '){2}'
second = '(?:' + DIGIT + '){2}'
timeOfDay = hour + ':' + minute + '(?::' + second + ')?'
zone = FWS + '[+-](?:' + DIGIT + '){4}'
time = timeOfDay + zone
dateTime = '(?:' + dayOfWeek + ',)?' + date + time + '(?:' + CFWS + ')?'

# Representing a decimal integer value in the range 0 through 255
snum = '(?:' + DIGIT + '){1,3}'

ipv4AddressLiteral = snum + '(?:\.' + snum + '){3}'
ipv6Hex = '(?:' + HEXDIG + '){1,4}'
ipv6Full = ipv6Hex + '(?::' + ipv6Hex + '){7}'

# The "::" represents at least 2 16-bit groups of zeros.  No more than 6
# groups in addition to the "::" may be present
ipv6Comp = '(?:' + ipv6Hex + '(?::' + ipv6Hex + '){,5})?::(?:' + ipv6Hex + '(?::' + ipv6Hex + '){,5})?'

ipv6v4Full = ipv6Hex + '(?::' + ipv6Hex + '){5}:' + ipv4AddressLiteral

# The "::" represents at least 2 16-bit groups of zeros.  No more than 4
# groups in addition to the "::" and IPv4-address-literal may be present
ipv6v4Comp = '(?:' + ipv6Hex + '(?::' + ipv6Hex + '){,3})?::(?:' + ipv6Hex + '(?::' + ipv6Hex + '){,3}:)?' + ipv4AddressLiteral

ipv6Addr = '(?:' + ipv6Full + '|' + ipv6Comp + '|' + ipv6v4Full + '|' + ipv6v4Comp + ')'
ipv6AddressLiteral = 'IPv6:' + ipv6Addr

letDig = '(?:' + ALPHA + '|' + DIGIT + ')'
ldhStr = '(?:' + ALPHA + '|' + DIGIT + '|-)*' + letDig

# Standardized-tag MUST be specified in a Standards-Track RFC and
# registered with IANA
standardizedTag = ldhStr

# Printable US-ASCII characters not including "[", "]", or "\"
dcontent = '[!-Z^-~]'

generalAddressLiteral = standardizedTag + ':' + '(?:' + dcontent + ')+'
addressLiteral = '\[(?:' + ipv4AddressLiteral + '|' + ipv6AddressLiteral + '|' + generalAddressLiteral + ')]'

subDomain = letDig + '(?:' + ldhStr + ')?'
domain = subDomain + '(?:\.' + subDomain + ')*'

# Information derived by server from TCP connection not client EHLO
tcpInfo = '(?:' + addressLiteral + '|' + domain + FWS + addressLiteral + ')'

extendedDomain = '(?:' + domain + '|' + domain + FWS + '\(' + tcpInfo + '\)|' + addressLiteral + FWS + '\(' + tcpInfo + '\))'
fromDomain = 'from' + FWS + extendedDomain
byDomain = CFWS + 'by' + FWS + extendedDomain
atom = '(?:' + atext + ')+'
addtlLink = atom
link = '(?:TCP|' + addtlLink + ')'
via = CFWS + 'via' + FWS + link

# Upstream client authenticated,
# http://thread.gmane.org/gmane.mail.postfix.user/215958
protocol = 'ESMTPA'

With = CFWS + 'with' + FWS + protocol
id = CFWS + 'id' + FWS + '(?:' + atom + '|' + msgId + ')'
atDomain = '@' + domain

# Note that this form, the so-called "source route", MUST be accepted,
# SHOULD NOT be generated, and SHOULD be ignored
adl = atDomain + '(?:,' + atDomain + ')*'

dotString = atom + '(?:\.' + atom + ')*'
qtextSmtp = '[ !#-[\]-~]'
quotedPairSmtp = '\\[ -~]'
qcontentSmtp = '(?:' + qtextSmtp + '|' + quotedPairSmtp + ')'
quotedString = DQUOTE + '(?:' + qcontentSmtp + ')*' + DQUOTE
localPart = '(?:' + dotString + '|' + quotedString + ')'
mailbox = localPart + '@(?:' + domain + '|' + addressLiteral + ')'
path = '<(?:' + adl + ':)?' + mailbox + '>'
For = CFWS + 'for' + FWS + '(?:' + path + '|' + mailbox + ')'
string = '(?:' + atom + '|' + quotedString + ')'

# Additional standard clauses may be added in this location by future
# standards and registered with IANA.  SMTP servers SHOULD NOT use
# unregistered names
additionalRegisteredClauses = CFWS + atom + FWS + string

optInfo = '(?:' + via + ')?(?:' + With + ')?(?:' + id + ')?(?:' + For + ')?(?:' + additionalRegisteredClauses + ')?'
stamp = fromDomain + byDomain + optInfo + '(?:' + CFWS + ')?;' + FWS + dateTime

timeStampLine = 'Received:' + FWS + stamp + CRLF

pool = adbapi.ConnectionPool('MySQLdb', db='cookie', user='root')

# Buffer lines to .data, call .deferred on delivery success or failure
class Message:
  def eomReceived(self):
    self.deferred = defer.Deferred()

    # No need to compile regex, most recent patterns are cached,
    # http://docs.python.org/library/re#re.compile
    if re.match(timeStampLine, self.data.getvalue()):
      def sub(sender):
        sender += '@nottheoilrig.com'

        def repl(match):
          repl = 'From:'

          # displayName
          if match.group(1):
            repl += match.group(1)

          # angleAddr
          if match.group(3):
            repl += match.group(3)

            # localPart dotAtom
            if match.group(4):
              repl += match.group(4)

            # localPart quotedString
            elif match.group(6):
              repl += match.group(6)

            repl += sender

            # domain dotAtom
            if match.group(8):
              repl += match.group(8)

            # domain domainLiteral
            elif match.group(9):
              repl += match.group(9)

            repl += match.group(10)

          else:

            # localPart dotAtom
            if match.group(11):
              repl += match.group(11)

            # localPart quotedString
            elif match.group(13):
              repl += match.group(13)

            repl += sender

            # domain dotAtom
            if match.group(14):
              repl += match.group(14)

            # domain domainLiteral
            elif match.group(16):
              repl += match.group(16)

          repl += '\n'

          return repl

        self.data.seek(0)
        self.data.write(re.sub(From, repl, self.data.getvalue(), 1))
        self.data.truncate()

        message.append(self)

        deferred.callback(None)

      def address():
        def select():
          conn = adbapi.Connection(pool)
          trans = adbapi.Transaction(pool, conn)

          trans.execute('SELECT sender FROM address WHERE address = %s', self.user)
          result = trans.fetchall()
          trans.close()

          return result

        def callback(result):
          try:
            sub(result[0][0])

          except IndexError:
            alphabet = '0123456789abcdefghijklmnopqrstuvwxyz'

            letter = random()
            sender = ''
            for ignore in range(6):
              letter *= len(alphabet)
              sender += alphabet[int(letter)]
              letter -= int(letter)

            def insert():
              conn = adbapi.Connection(pool)
              trans = adbapi.Transaction(pool, conn)

              trans.execute('INSERT INTO address (address, sender) VALUES (%s, %s)', (self.user, sender))
              trans.close()

            def callback(result):
              sub(sender)

            threads.deferToThreadPool(reactor, pool.threadpool, insert).addCallback(callback)

        threads.deferToThreadPool(reactor, pool.threadpool, select).addCallback(callback)

      def messageId(pattern, fallback):

        # TODO Support multiple message ids, regex currently supports only one
        match = re.search(pattern, self.data.getvalue())
        if match:
          def select():
            conn = adbapi.Connection(pool)
            trans = adbapi.Transaction(pool, conn)

            trans.execute('SELECT sender FROM message_id WHERE message_id = %s', match.group(1))
            result = trans.fetchall()
            trans.close()

            return result

          def callback(result):
            try:
              sub(result[0][0])

            except IndexError:
              fallback()

          threads.deferToThreadPool(reactor, pool.threadpool, select).addCallback(callback)

        else:
          fallback()

      # Check first for existing address associated with In-Reply-To message
      # id, then References message id, then recipient address, and finally
      # generate new address
      messageId(inReplyTo, lambda: messageId(references, address))

    else:
      match = re.search(messageId, self.data.getvalue())
      if match:
        def select():
          conn = adbapi.Connection(pool)
          trans = adbapi.Transaction(pool, conn)

          trans.execute('SELECT COUNT(*) FROM address WHERE sender = %s', self.user.dest.local)
          result = trans.fetchall()
          trans.close()

          return result

        def callback(result):
          if result[0][0]:
            def insert():
              conn = adbapi.Connection(pool)
              trans = adbapi.Transaction(pool, conn)

              trans.execute('INSERT INTO message_id (message_id, sender) VALUES (%s, %s)', (match.group(1), self.user.dest.local))
              trans.close()

            def callback(result):
              message.append(self)

              deferred.callback(None)

            threads.deferToThreadPool(reactor, pool.threadpool, insert).addCallback(callback)

          else:
            message.append(self)

            deferred.callback(None)

        threads.deferToThreadPool(reactor, pool.threadpool, select).addCallback(callback)

      else:
        message.append(self)

        deferred.callback(None)

    return self.deferred

  def lineReceived(self, line):
    self.data.write(line + "\n")

# Ignore lines, only buffer once per message, use for multiple recipients
class NullMessage(Message):
  def lineReceived(self, line):
    pass

class SMTPServer(smtp.ESMTP):
  def connectionMade(self):
    global clientService, running

    if not running:
      try:
        clientService.startService()

      except NameError:
        factory = SMTPClientFactory()

        clientService = internet.TCPClient('localhost', 1894, factory)
        clientService.setServiceParent(application)

      running = True

    return smtp.ESMTP.connectionMade(self)

  def do_EHLO(self, rest):
    peer = self.transport.getPeer().host
    self._helo = (rest, peer)
    self._from = None
    self._to = []

    def callback(result):
      self.sendCode(*result)

      return result

    ehlo.addCallback(callback)

  # Suppress Received header because we're a content filter
  def receivedHeader(self, helo, origin, recipients):
    pass

  # Message for first recipient
  def validateFrom(self, helo, origin):
    self.data = StringIO()
    self.message = Message()

    return origin

  def validateTo(self, user):
    message = self.message
    message.data = self.data
    message.user = user

    # NullMessage for subsequent recipients
    self.message = NullMessage()

    return lambda: message

# ESMTPFactory doesn't exist
class SMTPServerFactory(smtp.SMTPFactory):
  protocol = SMTPServer

factory = SMTPServerFactory()

serverService = internet.TCPServer(1438, factory, interface='localhost')
serverService.setServiceParent(application)

class Request(http.Request):
  def process(self):
    if not re.match('/' + addrSpec, self.path):
      self.setResponseCode(http.NOT_FOUND)

      self.finish()

    else:
      def select():
        conn = adbapi.Connection(pool)
        trans = adbapi.Transaction(pool, conn)

        trans.execute('SELECT sender FROM address WHERE address = %s', self.path[1:])
        result = trans.fetchall()
        trans.close()

        return result

      def callback(result):
        try:
          self.write(result[0][0])

        except IndexError:
          alphabet = '0123456789abcdefghijklmnopqrstuvwxyz'

          letter = random()
          sender = ''
          for ignore in range(6):
            letter *= len(alphabet)
            sender += alphabet[int(letter)]
            letter -= int(letter)

          def insert():
            conn = adbapi.Connection(pool)
            trans = adbapi.Transaction(pool, conn)

            trans.execute('INSERT INTO address (address, sender) VALUES (%s, %s)', (self.path[1:], sender))
            trans.close()

          def callback(result):
            self.write(sender)

            self.finish()

          threads.deferToThreadPool(reactor, pool.threadpool, insert).addCallback(callback)

        else:
          self.finish()

      threads.deferToThreadPool(reactor, pool.threadpool, select).addCallback(callback)

class HTTPServer(http.HTTPChannel):
  requestFactory = Request

class HTTPServerFactory(http.HTTPFactory):
  protocol = HTTPServer

factory = HTTPServerFactory()

serverService = internet.TCPServer(8743, factory, interface='localhost')
serverService.setServiceParent(application)
