#!/usr/bin/env python

import base64, re, socket
from Crypto.Cipher import AES
from StringIO import StringIO
from twisted.application import internet, service
from twisted.internet import defer, protocol
from twisted.mail import smtp

application = service.Application('cookie')

ehlo = defer.Deferred()

message = []

# Can't otherwise tell if client is running or disconnecting
running = False

class Client(smtp.ESMTPClient):

  # Shortcut ESMTPClient.__init__(), no authentication or TLS
  def __init__(self, *args, **kw):
    self.secret = None

    return smtp.SMTPClient.__init__(self, *args, **kw)

  def esmtpState_serverConfig(self, *args, **kw):
    try:
      ehlo.callback(args)

    except defer.AlreadyCalledError:
      ehlo.result = args

    return smtp.ESMTPClient.esmtpState_serverConfig(self, *args, **kw)

  def getMailData(self):
    message[0].data.seek(0)

    return message[0].data

  def getMailFrom(self):
    return message[0].user.orig

  def getMailTo(self):
    return [str(message[0].user)]

  # Wait for message from client
  def smtpState_from(self, code, resp):
    global deferred

    if message:
      return smtp.ESMTPClient.smtpState_from(self, code, resp)

    deferred = defer.Deferred()
    deferred.addCallback(lambda(result): smtp.ESMTPClient.smtpState_from(self, code, resp))

  def smtpState_msgSent(self, code, resp):
    global message, running

    message[0].deferred.callback(None)

    message = message[1:]
    if message:
      self._from = None
      self.toAddressesResult = []

      return smtp.ESMTPClient.smtpState_msgSent(self, code, resp)

    # No more messages to send
    running = False

    self._disconnectFromServer()

# Cache our domain
domain = socket.getfqdn()

class ClientFactory(protocol.ClientFactory):
  domain = domain
  protocol = Client

  def buildProtocol(self, addr):
    return self.protocol(self.domain)

key = base64.b16decode('8c669a8a0f86bc02abd3516b9f90bd83d08a06ebd280fd0814053cbd706930ff', True)
cipher = AES.new(key)

# Buffer lines to .data, call .deferred on delivery success or failure
class Message:
  def eomReceived(self):

    # Use local newlines
    CRLF = '\n'

    WSP = '[\t ]'

    # Folding white space
    FWS = '(?:(?:' + WSP + ')*' + CRLF + ')?(?:' + WSP + ')+'

    # Comments are recursive, add support later
    CFWS = FWS

    ALPHA = '[A-Za-z]'
    DIGIT = '\d'

    # Printable US-ASCII characters not including specials.  Used for atoms
    atext = '(?:[!#$%&\'*+\-/=?^_`{|}~]|' + ALPHA + '|' + DIGIT + ')'

    atom = '(?:' + CFWS + ')?(?:' + atext + ')+(?:' + CFWS + ')?'
    DQUOTE = '"'

    # Printable US-ASCII characters not including "\" or the quote character
    qtext = '[!#-[\]-~]'

    VCHAR = '[!-~]'
    quotedPair = '\\\(?:' + VCHAR + '|' + WSP + ')'
    qcontent = '(?:' + qtext + '|' + quotedPair + ')'
    quotedString = '(' + CFWS + ')?' + DQUOTE + '(?:(?:' + FWS + ')?' + qcontent + ')*(?:' + FWS + ')?' + DQUOTE + '(?:' + CFWS + ')?'
    word = '(?:' + atom + '|' + quotedString + ')'
    phrase = '(?:' + word + ')+'
    displayName = phrase
    dotAtomText = '(?:' + atext + ')+(?:\.(?:' + atext + ')+)*'
    dotAtom = '(' + CFWS + ')?' + dotAtomText + '(' + CFWS + ')?'
    localPart = '(?:' + dotAtom + '|' + quotedString + ')'

    # Printable US-ASCII characters not including "[", "]", or "\"
    dtext = '[!-Z^-~]'

    domainLiteral = '(?:' + CFWS + ')?\[(?:(?:' + FWS + ')?' + dtext + ')*(?:' + FWS + ')?](' + CFWS + ')?'
    domain = '(?:' + dotAtom + '|' + domainLiteral + ')'
    addrSpec = localPart + '@' + domain
    angleAddr = '((?:' + CFWS + ')?<)' + addrSpec + '(>(?:' + CFWS + ')?)'
    nameAddr = '(' + displayName + ')?' + angleAddr
    mailbox = '(?:' + nameAddr + '|' + addrSpec + ')'

    pattern = 'From:' + mailbox + CRLF

    def repl(match):
      sender = str(self.user)

      # http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Padding
      sender += '\0' * (cipher.block_size - (len(sender) - 1) % cipher.block_size - 1)

      sender = cipher.encrypt(sender)
      sender = base64.b64encode(sender)
      sender += '@nottheoilrig.com'

      repl = 'From:'

      # displayName
      if match.group(1):
        repl += match.group(1)

      # angleAddr
      if match.group(3):
        repl += match.group(3)

        # localPart dotAtom
        if match.group(4):
          repl += match.group(4)

        # localPart quotedString
        elif match.group(6):
          repl += match.group(6)

        repl += sender

        # domain dotAtom
        if match.group(8):
          repl += match.group(8)

        # domain domainLiteral
        elif match.group(9):
          repl += match.group(9)

        repl += match.group(10)

      else:

        # localPart dotAtom
        if match.group(11):
          repl += match.group(11)

        # localPart quotedString
        elif match.group(13):
          repl += match.group(13)

        repl += sender

        # domain dotAtom
        if match.group(14):
          repl += match.group(14)

        # domain domainLiteral
        elif match.group(16):
          repl += match.group(16)

      repl += '\n'

      return repl

    self.data.seek(0)
    self.data.write(re.sub(pattern, repl, self.data.getvalue(), 1))
    self.data.truncate()

    self.deferred = defer.Deferred()

    message.append(self)

    deferred.callback(None)

    return self.deferred

  def lineReceived(self, line):
    self.data.write(line + "\n")

# Ignore lines, only buffer once per message, use for multiple recipients
class NullMessage(Message):
  def lineReceived(self, line):
    pass

class Server(smtp.ESMTP):
  def connectionMade(self):
    global clientService, running

    if not running:
      try:
        clientService.startService()

      except NameError:
        factory = ClientFactory()

        clientService = internet.TCPClient('localhost', 1894, factory)
        clientService.setServiceParent(application)

      running = True

    return smtp.ESMTP.connectionMade(self)

  def do_EHLO(self, rest):
    peer = self.transport.getPeer().host
    self._helo = (rest, peer)
    self._from = None
    self._to = []

    def callback(result):
      self.sendCode(*result)

      return result

    ehlo.addCallback(callback)

  # Suppress Received header because we're a content filter
  def receivedHeader(self, helo, origin, recipients):
    pass

  # Message for first recipient
  def validateFrom(self, helo, origin):
    self.data = StringIO()
    self.message = Message()

    return origin

  def validateTo(self, user):
    message = self.message
    message.data = self.data
    message.user = user

    # NullMessage for subsequent recipients
    self.message = NullMessage()

    return lambda: message

# ESMTPFactory doesn't exist
class ServerFactory(smtp.SMTPFactory):
  protocol = Server

factory = ServerFactory()

serverService = internet.TCPServer(1438, factory, interface='localhost')
serverService.setServiceParent(application)
