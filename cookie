#!/usr/bin/env python

import sys, untwisted
from qwer import *
from random import random
from twisted.internet import reactor
from twisted.python import log
from twisted.web import http
from untwisted import db, promise, rfc5234, rfc5321, rfc5322, smtp, tcp

log.startLogging(sys.stdout)

conn = db.connect(db='cookie', user='root')

# Lookup sender address for recognized recipient or generate sender address for
# unrecognized recipient
def address(recipient):
  try:
    for cursor in conn:
      sender, = cursor.execute('SELECT sender FROM address WHERE address = %s', recipient).next()

  except StopIteration:
    alphabet = '0123456789abcdefghijklmnopqrstuvwxyz'

    # Choose six letters from alphabet, at random
    letter = random()
    sender = ''
    for _ in range(6):
      letter *= len(alphabet)
      sender += alphabet[int(letter)]
      letter -= int(letter)

    for cursor in conn:
      cursor.execute('INSERT INTO address (address, sender) VALUES (%s, %s)', recipient, sender)

  return sender

@untwisted.call
@promise.continuate
def _():
  connect = tcp.connect('localhost', 1894)

  class server(smtp.server):
    class __metaclass__(smtp.server.__metaclass__):

      @promise.continuate
      def __call__(ctx, transport):
        ctx = type.__call__(ctx, transport)

        # Technically we needn't wait for a downstream connection or greeting
        # before processing an upstream MAIL command, but this complicates our
        # implementation: We *must* wait for a downstream connection before
        # issuing any downstream commands.  Receiving a MAIL command before a
        # hello command - or receiving *any* command before issuing a greeting
        # - is in violation of SMTP specification, so advantage of this
        # optimization is vanishing
        #
        #ctx.client = smtp.pipeline(connect())
        #ctx.client.transport.then(untwisted.partial(setattr, ctx.client, 'transport'))
        ctx.client = type.__call__(smtp.pipeline, (yield connect()))

        # Greeting
        transport.write(str((yield ctx.client.reply(untwisted.wildcard))))

        # Proxy all commands outside mail transaction
        #return ...
        raise StopIteration(ctx.mail())

    reset = False

    class mail(smtp.server.mail):
      def __init__(ctx):
        smtp.server.mail.__init__(ctx)

        ctx.recipient = [].append

      def sender(ctx, sender):
        ctx.sender = sender

      @promise.continuate
      def start(ctx, command, state):
        if 'MAIL' == command.verb:
          #return ...
          raise StopIteration(smtp.server.mail.start(ctx, command, state))

        try:
          ctx.ctx.reset = yield ctx.ctx.reset

        except smtp.reply:
          ctx.ctx.reset = True

        # Proxy all commands outside mail transaction
        ctx.ctx.client.transport.write(str(command))

        try:
          reply = yield ctx.ctx.client.reply()

        except smtp.reply as reply:
          pass

        else:
          if command.verb in ('EHLO', 'HELO', 'RSET'):
            ctx.ctx.reset = False

        ctx.ctx.transport.write(str(reply))

        #return ...
        raise StopIteration(state((yield ctx.ctx.command()), state))

      @promise.continuate
      def content(ctx, content):
        if (yield ctx.ctx.reset):
          rsetReply = ctx.ctx.client.rset()

        mail = type.__call__(ctx.ctx.client.mail)

        # Upstream client authenticated,
        # http://thread.gmane.org/gmane.mail.postfix.user/215958
        protocol = 'ESMTPA'

        With = qwer(rfc5322.CFWS, 'with', rfc5322.FWS, protocol)
        optInfo = qwer('(?:', rfc5321.via, ')?', With, '(?:', rfc5321.id, ')?(?:', rfc5321.For, ')?(?:', rfc5321.additionalRegisteredClauses, ')?')
        stamp = qwer(rfc5321.fromDomain, rfc5321.byDomain, optInfo, '(?:', rfc5322.CFWS, ')?;', rfc5322.FWS, rfc5322.dateTime)
        timeStampLine = qwer('Received:', rfc5322.FWS, stamp, rfc5234.CRLF)

        try:
          timeStampLine.match(content)

        # Not authenticated, ESMTPA
        except ValueError:
          try:
            messageId = rfc5322.messageId.search(content, 'idLeft, idRight')

          except ValueError:
            pass

          else:
            for recipient in ctx.recipient.__self__:
              for cursor in conn:
                count, = cursor.execute('SELECT COUNT(*) FROM address WHERE sender = %s', recipient.localPart).next()

              if count:
                for cursor in conn:
                  cursor.execute('INSERT INTO message_id (message_id, sender) VALUES (%s, %s)', messageId.join('@'), recipient.localPart)

          mailReply = mail.mail(ctx.sender)

          for recipient in ctx.recipient.__self__:
            mail.rcpt(recipient)

          try:
            dataReply = yield mail.data(content)

          except smtp.reply as e:

            # Pipeline: reset = not rsetReply or mailReply
            try:
              try:
                yield rsetReply

              except UnboundLocalError:
                pass

              try:
                yield mailReply

                ctx.ctx.reset = True

              except smtp.reply as e:
                ctx.ctx.reset = False

            except smtp.reply as e:
              ctx.ctx.reset = True

            ctx.ctx.transport.write(str(e))

            #return ...
            raise StopIteration(ctx.afterRecipient((yield ctx.ctx.command()), ctx.afterRecipient))

          raise (yield dataReply)

        # Authenticated, ESMTPA

        def messageId(qwer):
          try:
            msgId = qwer.search(content, 'msgId ( idLeft, idRight )')

          except ValueError:
            raise Exception

          # TODO
          for msgId in msgId:
            try:
              for cursor in conn:
                sender, = cursor.execute('SELECT sender FROM message_id WHERE message_id = %s', msgId['*'].join('@')).next()

            except StopIteration:
              raise Exception

            return sender

        def replace(sender, mailbox):
          result = 'From:'

          if mailbox.nameAddr:
            result += str(mailbox.displayName) + str(mailbox['nameAddr > CFWS:first-child']) + '<' + str(mailbox['localPart > CFWS:first-child']) + sender + str(mailbox['localPart > * + CFWS']) + '@' + str(mailbox['domain > CFWS:first-child']) + 'nottheoilrig.com' + str(mailbox['domain > * + CFWS']) + '>' + str(mailbox['nameAddr > * + CFWS'])

          else:
            result += str(mailbox['localPart > CFWS:first-child']) + sender + str(mailbox['localPart > * + CFWS']) + '@' + str(mailbox['domain > CFWS:first-child']) + 'nottheoilrig.com' + str(mailbox['domain > * + CFWS'])

          result += '\r\n'

          return result

        # Replace sender address and send mail to one or many recipients

        @promise.continuate
        def send(*recipient):
          mailReply = mail.mail(sender + '@nottheoilrig.com')

          for recipient in recipient:
            mail.rcpt(recipient)

          try:
            dataReply = yield mail.data(rfc5322.From.replace(untwisted.partial(replace, sender), content, 'mailbox ( nameAddr, displayName, CFWS, localPart, dotAtomText, DQUOTE, domain )', count=1))

          except smtp.reply as e:

            # Pipeline: reset = not rsetReply or mailReply
            try:
              try:
                yield rsetReply

              except NameError:
                pass

              try:
                yield mailReply

                ctx.ctx.reset = True

              except smtp.reply as e:
                ctx.ctx.reset = False

            except smtp.reply as e:
              ctx.ctx.reset = True

            ctx.ctx.transport.write(str(e))

            #return ...
            raise StopIteration(ctx.afterRecipient((yield ctx.ctx.command()), ctx.afterRecipient))

          #return ...
          raise StopIteration(promise.promise()(dataReply))

        try:
          sender = yield messageId(rfc5322.inReplyTo)

        except Exception:
          try:
            sender = yield messageId(rfc5322.references)

          except Exception:

            # Wait for first mail, an unexpected reply falls through, aborting
            # this and additional mail.  An unexpected reply is caught and
            # proxied to the upstream client.  All success replies are
            # expected, so an unexpected reply is an error

            #head, *rest = ctx.recipient.__self__
            head, rest = ctx.recipient.__self__[0], ctx.recipient.__self__[1:]

            # Closure
            sender = address(head)

            reply = yield send(head)

            @untwisted.partial(setattr, ctx.ctx, 'reset')
            @untwisted.call
            @promise.continuate
            def _():
              reset = False

              for recipient in rest:
                if reset:
                  rsetReply = ctx.ctx.client.rset()

                sender = address(recipient)

                mailReply = mail.mail(sender + '@nottheoilrig.com')

                mail.rcpt(recipient)

                try:
                  yield mail.data(rfc5322.From.replace(untwisted.partial(replace, sender), content, 'mailbox ( nameAddr, displayName, CFWS, localPart, dotAtomText, DQUOTE, domain )', count=1))

                except smtp.reply:

                  # Pipeline: reset = not rsetReply or mailReply
                  try:
                    try:
                      yield rsetReply

                    except UnboundLocaError:
                      pass

                    try:
                      yield mailReply

                      reset = True

                    except smtp.reply:
                      reset = False

                  except smtp.reply:
                    reset = True

                  # TODO Bounce

              #return ...
              raise StopIteration(reset)

            raise (yield reply)

        raise (yield (yield send(*ctx.recipient.__self__)))

  listen = tcp.listen(1438, interface='localhost')
  while True:
    server((yield listen()))

@untwisted.call
class factory(http.HTTPFactory):
  class protocol(http.HTTPChannel):
    class requestFactory(http.Request):
      def process(ctx):
        try:
          qwer('/', rfc5322.addrSpec).match(ctx.path)

        except ValueError:
          ctx.setResponseCode(http.NOT_FOUND)

        else:
          ctx.write(address(ctx.path[1:]))

        ctx.finish()

reactor.listenTCP(8743, factory, interface='localhost')

reactor.run()
