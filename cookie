#!/usr/bin/env python

import sys, untwisted
from qwer import *
from random import random
from twisted.internet import reactor
from twisted.python import log
from twisted.web import http
from untwisted import db, promise, rfc5321, rfc5322, smtp, tcp

log.startLogging(sys.stdout)

conn = db.connect(db='cookie', user='root')

@untwisted.call
@promise.continuate
def _():
  connect = tcp.connect('localhost', 1894)

  class server(smtp.server):
    class __metaclass__(smtp.server.__metaclass__):

      @promise.continuate
      def __call__(ctx, transport):
        server = type.__call__(ctx, transport)

        # Technically we needn't wait for a downstream connection or greeting
        # before processing an upstream MAIL command, but this complicates our
        # implementation: We *must* wait for a downstream connection before
        # issuing any downstream commands.  Receiving a MAIL command before a
        # hello command - or receiving *any* command before issuing a greeting -
        # is in violation of SMTP specification, so advantages of this
        # optimization are vanishing
        #
        #server.client = smtp.client(connect())
        #server.client.transport.then(untwisted.partial(setattr, server.client, 'transport'))
        server.client = type.__call__(smtp.client, (yield connect()))

        # Greeting
        transport.write(str((yield server.client.reply(untwisted.wildcard))))

        # Proxy all commands outside mail transaction
        #return ...
        raise StopIteration(server.mail())

    class mail(smtp.server.mail):
      def __init__(ctx):
        smtp.server.mail.__init__(ctx)

        ctx.recipient = [].append

      def mail(ctx, mailbox):
        ctx.sender = mailbox

      @promise.continuate
      def start(ctx, command, state):
        if 'MAIL' == command.verb:
          #return ...
          raise StopIteration(smtp.server.mail.start(ctx, command, state))

        # Proxy all commands outside mail transaction
        ctx.ctx.client.transport.write(str(command))

        ctx.ctx.transport.write(str((yield ctx.ctx.client.reply(untwisted.wildcard))))

        #return ...
        raise StopIteration(state((yield ctx.ctx.command()), state))

      @promise.continuate
      def data(ctx, data):
        mail = type.__call__(ctx.ctx.client.mail)

        try:
          rfc5321.timeStampLine.match(data)

        # Not authenticated, ESMTPA
        except ValueError:
          try:
            messageId = rfc5322.messageId.search(data, 'idLeft, idRight')

          except ValueError:
            pass

          else:
            for recipient in ctx.recipient.__self__:
              try:
                cursor = conn.cursor()
                cursor.execute('SELECT COUNT(*) FROM address WHERE sender = %s', recipient.localPart)
                count, = cursor.next()

              finally:
                cursor.close()

              if count:
                try:
                  cursor = conn.cursor()
                  cursor.execute('INSERT INTO message_id (message_id, sender) VALUES (%s, %s)', messageId.join('@'), recipient.localPart)

                finally:
                  cursor.close()

          try:
            yield mail.mailCmd(ctx.sender)

          except smtp.reply as e:
            ctx.ctx.transport.write(str(e))

            #return ...
            raise StopIteration(ctx.afterRecipient((yield ctx.ctx.command()), ctx.afterRecipient))

          for recipient in ctx.recipient.__self__:
            try:
              yield mail.rcptCmd(recipient)

            except smtp.reply as e:
              ctx.ctx.transport.write(str(e))

              #return ...
              raise StopIteration(ctx.afterRecipientZxcv((yield ctx.ctx.command()), ctx.afterRecipientZxcv))

          try:
            reply = yield mail.dataCmd(data)

          except smtp.reply as e:
            ctx.ctx.transport.write(str(e))

            #return ...
            raise StopIteration(ctx.afterRecipientZxcv((yield ctx.ctx.command()), ctx.afterRecipientZxcv))

          raise reply

        # Authenticated, ESMTPA

        def messageId(qwer):
          try:
            msgId = qwer.search(data, 'msgId ( idLeft, idRight )')

          except ValueError:
            raise Exception

          # TODO
          for msgId in msgId:
            try:
              try:
                cursor = conn.cursor()
                cursor.execute('SELECT sender FROM message_id WHERE message_id = %s', msgId['*'].join('@'))
                sender, = cursor.next()

              finally:
                cursor.close()

            except StopIteration:
              raise Exception

            return sender

        def replace(mailbox):
          result = 'From:'

          if mailbox.nameAddr:
            result += str(mailbox.displayName) + str(mailbox['nameAddr > CFWS:first-child']) + '<' + str(mailbox['localPart > CFWS:first-child']) + sender + str(mailbox['localPart > * + CFWS']) + '@' + str(mailbox['domain > CFWS:first-child']) + 'nottheoilrig.com' + str(mailbox['domain > * + CFWS']) + '>' + str(mailbox['nameAddr > * + CFWS'])

          else:
            result += str(mailbox['localPart > CFWS:first-child']) + sender + str(mailbox['localPart > * + CFWS']) + '@' + str(mailbox['domain > CFWS:first-child']) + 'nottheoilrig.com' + str(mailbox['domain > * + CFWS'])

          result += '\r\n'

          return result

        # Filter/forward/proxy message with sender and recipient

        @promise.continuate
        def filter(*recipient):
          try:
            yield mail.mailCmd(sender + '@nottheoilrig.com')

          # Client only raises reply if unexpected/unsuccessful
          except smtp.reply as e:
            ctx.ctx.transport.write(str(e))

            #return ...
            raise StopIteration(ctx.afterRecipient((yield ctx.ctx.command()), ctx.afterRecipient))

          for itm in recipient:
            try:
              yield mail.rcptCmd(itm)

            # Client only raises reply if unexpected/unsuccessful
            except smtp.reply as e:
              ctx.ctx.transport.write(str(e))

              #return ...
              raise StopIteration(ctx.afterRecipientZxcv((yield ctx.ctx.command()), ctx.afterRecipientZxcv))

          try:
            #return ...
            raise StopIteration(mail.dataCmd(rfc5322.From.replace(replace, data, 'mailbox ( nameAddr, displayName, CFWS, localPart, dotAtomText, DQUOTE, domain )', count=1)))

          # Client only raises reply if unexpected/unsuccessful
          except smtp.reply as e:
            ctx.ctx.transport.write(str(e))

            #return ...
            raise StopIteration(ctx.afterRecipientZxcv((yield ctx.ctx.command()), ctx.afterRecipientZxcv))

        try:
          sender = yield messageId(rfc5322.inReplyTo)

        except Exception:
          try:
            sender = yield messageId(rfc5322.references)

          except Exception:

            # Send/forward/proxy to one recipient, generating new sender

            def asdf(recipient):
              try:
                try:
                  cursor = conn.cursor()
                  cursor.execute('SELECT sender FROM address WHERE address = %s', recipient)
                  sender, = cursor.next()

                finally:
                  cursor.close()

              except StopIteration:
                alphabet = '0123456789abcdefghijklmnopqrstuvwxyz'

                # Choose six letters from alphabet, at random
                letter = random()
                sender = ''
                for _ in range(6):
                  letter *= len(alphabet)
                  sender += alphabet[int(letter)]
                  letter -= int(letter)

                try:
                  cursor = conn.cursor()
                  cursor.execute('INSERT INTO address (address, sender) VALUES (%s, %s)', recipient, sender)

                finally:
                  cursor.close()

              return sender

            # Wait for first mail, an unexpected reply falls through, aborting
            # this and additional mail.  An unexpected reply is caught and
            # proxied to the incoming client.  All success replies are
            # expected, so an unexpected reply is an error

            #head, *rest = ctx.recipient.__self__
            head, rest = ctx.recipient.__self__[0], ctx.recipient.__self__[1:]

            # Closure
            sender = asdf(head)

            reply = yield filter(head)

            @untwisted.call
            @promise.continuate
            def _():
              for recipient in rest:
                sender = asdf(recipient)

                try:
                  yield mail.mailCmd(sender + '@nottheoilrig.com')

                  yield mail.rcptCmd(recipient)

                  yield mail.dataCmd(rfc5322.From.replace(replace, data, 'mailbox ( nameAddr, displayName, CFWS, localPart, dotAtomText, DQUOTE, domain )', count=1))

                # Client only raises reply if unexpected/unsuccessful
                except smtp.reply:

                  # TODO Bounce
                  pass

            raise reply

        raise (yield filter(*ctx.recipient.__self__))

      @promise.continuate
      def afterRecipientZxcv(ctx, command, state):
        if 'DATA' == command.verb:
          ctx.ctx.client.transport.write(str(smtp.command('RSET')))

          try:
            yield ctx.ctx.client.reply()

          except smtp.reply as e:
            ctx.ctx.transport.write(str(e))

            #return ...
            raise StopIteration(state((yield ctx.ctx.command()), state))

        #return ...
        raise StopIteration(ctx.afterRecipient(command, state))

  listen = tcp.listen(1438, interface='localhost')
  while True:
    server((yield listen()))

@untwisted.partial(reactor.listenTCP, 8743, interface='localhost')
@untwisted.call
class _(http.HTTPFactory):
  class protocol(http.HTTPChannel):
    class requestFactory(http.Request):
      def process(ctx):
        try:
          qwer('/', rfc5322.addrSpec).match(ctx.path)

        except ValueError:
          ctx.setResponseCode(http.NOT_FOUND)

        else:
          try:
            try:
              cursor = conn.cursor()
              cursor.execute('SELECT sender FROM address WHERE address = %s', ctx.path[1:])
              sender, = cursor.next()

            finally:
              cursor.close()

          except StopIteration:
            alphabet = '0123456789abcdefghijklmnopqrstuvwxyz'

            # Choose six letters from alphabet, at random
            letter = random()
            sender = ''
            for _ in range(6):
              letter *= len(alphabet)
              sender += alphabet[int(letter)]
              letter -= int(letter)

            try:
              cursor = conn.cursor()
              cursor.execute('INSERT INTO address (address, sender) VALUES (%s, %s)', ctx.path[1:], sender)

            finally:
              cursor.close()

          ctx.write(sender)

        ctx.finish()

reactor.run()
