#!/usr/bin/env python

import sys, untwisted
from qwer import *
from random import random
from twisted.internet import reactor
from twisted.python import log
from twisted.web import http
from untwisted import db, promise, rfc5321, rfc5322, smtp, tcp

log.startLogging(sys.stdout)

conn = db.connect(db='cookie', user='root')

# Lookup sender address for recognized recipient or generate sender address for
# unrecognized recipient
def address(recipient):
  try:
    for cursor in conn:
      sender, = cursor.execute('SELECT sender FROM address WHERE address = %s', recipient).next()

  except StopIteration:
    alphabet = '0123456789abcdefghijklmnopqrstuvwxyz'

    # Choose six letters from alphabet, at random
    letter = random()
    sender = ''
    for _ in range(6):
      letter *= len(alphabet)
      sender += alphabet[int(letter)]
      letter -= int(letter)

    for cursor in conn:
      cursor.execute('INSERT INTO address (address, sender) VALUES (%s, %s)', recipient, sender)

  return sender

@untwisted.call
@promise.continuate
def _():
  connect = tcp.connect('localhost', 1894)

  class server(smtp.server):
    class __metaclass__(smtp.server.__metaclass__):

      @promise.continuate
      def __call__(ctx, transport):
        ctx = type.__call__(ctx, transport)

        # Technically we needn't wait for a downstream connection or greeting
        # before processing an upstream MAIL command, but this complicates our
        # implementation: We *must* wait for a downstream connection before
        # issuing any downstream commands.  Receiving a MAIL command before a
        # hello command - or receiving *any* command before issuing a greeting -
        # is in violation of SMTP specification, so advantages of this
        # optimization are vanishing
        #
        #ctx.client = smtp.pipeline(connect())
        #ctx.client.transport.then(untwisted.partial(setattr, ctx.client, 'transport'))
        ctx.client = type.__call__(smtp.pipeline, (yield connect()))

        # Greeting
        transport.write(str((yield ctx.client.reply(untwisted.wildcard))))

        # Proxy all commands outside mail transaction
        #return ...
        raise StopIteration(ctx.mail())

    reset = False

    class mail(smtp.server.mail):
      def __init__(ctx):
        smtp.server.mail.__init__(ctx)

        ctx.recipient = [].append

      def mail(ctx, mailbox):
        ctx.sender = mailbox

      @promise.continuate
      def start(ctx, command, state):
        if 'MAIL' == command.verb:
          #return ...
          raise StopIteration(smtp.server.mail.start(ctx, command, state))

        try:
          ctx.ctx.reset = yield ctx.ctx.reset

        except smtp.reply:
          ctx.ctx.reset = True

        # Proxy all commands outside mail transaction
        ctx.ctx.client.transport.write(str(command))

        try:
          reply = yield ctx.ctx.client.reply()

        except smtp.reply as reply:
          pass

        else:
          if command.verb in ('EHLO', 'HELO', 'RSET'):
            ctx.ctx.reset = False

        ctx.ctx.transport.write(str(reply))

        #return ...
        raise StopIteration(state((yield ctx.ctx.command()), state))

      @promise.continuate
      def data(ctx, data):
        if (yield ctx.ctx.reset):
          try:
            rsetReply = yield ctx.ctx.client.rsetCmd()

          except smtp.reply as e:
            ctx.ctx.transport.write(str(e))

            #return ...
            raise StopIteration(ctx.afterRecipient((yield ctx.ctx.command()), ctx.afterRecipient))

          ctx.ctx.reset = False

        mail = type.__call__(ctx.ctx.client.mail)

        try:
          rfc5321.timeStampLine.match(data)

        # Not authenticated, ESMTPA
        except ValueError:
          try:
            messageId = rfc5322.messageId.search(data, 'idLeft, idRight')

          except ValueError:
            pass

          else:
            for recipient in ctx.recipient.__self__:
              for cursor in conn:
                count, = cursor.execute('SELECT COUNT(*) FROM address WHERE sender = %s', recipient.localPart).next()

              if count:
                for cursor in conn:
                  cursor.execute('INSERT INTO message_id (message_id, sender) VALUES (%s, %s)', messageId.join('@'), recipient.localPart)

          try:
            mailReply = yield mail.mailCmd(ctx.sender)

          except smtp.reply as e:
            ctx.ctx.transport.write(str(e))

            #return ...
            raise StopIteration(ctx.afterRecipient((yield ctx.ctx.command()), ctx.afterRecipient))

          for recipient in ctx.recipient.__self__:
            try:
              yield mail.rcptCmd(recipient)

            except smtp.reply as e:
              ctx.ctx.reset = True

              ctx.ctx.transport.write(str(e))

              #return ...
              raise StopIteration(ctx.afterRecipient((yield ctx.ctx.command()), ctx.afterRecipient))

          try:
            dataReply = yield mail.dataCmd(data)

          except smtp.reply as e:

            # Pipeline: reset = not rsetReply or mailReply
            try:
              try:
                yield rsetReply

              except UnboundLocalError:
                pass

              try:
                yield mailReply

                ctx.ctx.reset = True

              except smtp.reply as e:
                pass

            except smtp.reply as e:
              ctx.ctx.reset = True

            ctx.ctx.transport.write(str(e))

            #return ...
            raise StopIteration(ctx.afterRecipient((yield ctx.ctx.command()), ctx.afterRecipient))

          raise dataReply

        # Authenticated, ESMTPA

        def messageId(qwer):
          try:
            msgId = qwer.search(data, 'msgId ( idLeft, idRight )')

          except ValueError:
            raise Exception

          # TODO
          for msgId in msgId:
            try:
              for cursor in conn:
                sender, = cursor.execute('SELECT sender FROM message_id WHERE message_id = %s', msgId['*'].join('@')).next()

            except StopIteration:
              raise Exception

            return sender

        def replace(mailbox):
          result = 'From:'

          if mailbox.nameAddr:
            result += str(mailbox.displayName) + str(mailbox['nameAddr > CFWS:first-child']) + '<' + str(mailbox['localPart > CFWS:first-child']) + sender + str(mailbox['localPart > * + CFWS']) + '@' + str(mailbox['domain > CFWS:first-child']) + 'nottheoilrig.com' + str(mailbox['domain > * + CFWS']) + '>' + str(mailbox['nameAddr > * + CFWS'])

          else:
            result += str(mailbox['localPart > CFWS:first-child']) + sender + str(mailbox['localPart > * + CFWS']) + '@' + str(mailbox['domain > CFWS:first-child']) + 'nottheoilrig.com' + str(mailbox['domain > * + CFWS'])

          result += '\r\n'

          return result

        # Replace sender address and send mail to one or many recipients

        @promise.continuate
        def send(*recipient):
          try:
            mailReply = yield mail.mailCmd(sender + '@nottheoilrig.com')

          # Client only raises reply if unexpected/unsuccessful
          except smtp.reply as e:
            ctx.ctx.transport.write(str(e))

            #return ...
            raise StopIteration(ctx.afterRecipient((yield ctx.ctx.command()), ctx.afterRecipient))

          for itm in recipient:
            try:
              yield mail.rcptCmd(itm)

            # Client only raises reply if unexpected/unsuccessful
            except smtp.reply as e:
              ctx.ctx.reset = True

              ctx.ctx.transport.write(str(e))

              #return ...
              raise StopIteration(ctx.afterRecipient((yield ctx.ctx.command()), ctx.afterRecipient))

          try:
            #return ...
            raise StopIteration(mail.dataCmd(rfc5322.From.replace(replace, data, 'mailbox ( nameAddr, displayName, CFWS, localPart, dotAtomText, DQUOTE, domain )', count=1)))

          # Client only raises reply if unexpected/unsuccessful
          except smtp.reply as e:

            # Pipeline: reset = not rsetReply or mailReply
            try:
              try:
                yield rsetReply

              except NameError:
                pass

              try:
                yield mailReply

                ctx.ctx.reset = True

              except smtp.reply as e:
                pass

            except smtp.reply as e:
              ctx.ctx.reset = True

            ctx.ctx.transport.write(str(e))

            #return ...
            raise StopIteration(ctx.afterRecipient((yield ctx.ctx.command()), ctx.afterRecipient))

        try:
          sender = yield messageId(rfc5322.inReplyTo)

        except Exception:
          try:
            sender = yield messageId(rfc5322.references)

          except Exception:

            # Wait for first mail, an unexpected reply falls through, aborting
            # this and additional mail.  An unexpected reply is caught and
            # proxied to the incoming client.  All success replies are
            # expected, so an unexpected reply is an error

            #head, *rest = ctx.recipient.__self__
            head, rest = ctx.recipient.__self__[0], ctx.recipient.__self__[1:]

            # Closure
            sender = address(head)

            reply = yield send(head)

            @untwisted.partial(setattr, ctx.ctx, 'reset')
            @untwisted.call
            @promise.continuate
            def _():
              reset = False

              for recipient in rest:
                if reset:
                  try:
                    rsetReply = yield ctx.ctx.client.rsetCmd()

                  except smtp.reply:

                    # TODO Double bounce
                    raise

                  reset = False

                sender = address(recipient)

                try:
                  mailReply = yield mail.mailCmd(sender + '@nottheoilrig.com')

                  try:
                    yield mail.rcptCmd(recipient)

                    yield mail.dataCmd(rfc5322.From.replace(replace, data, 'mailbox ( nameAddr, displayName, CFWS, localPart, dotAtomText, DQUOTE, domain )', count=1))

                  except smtp.reply:

                    # Pipeline: reset = not rsetReply or mailReply
                    try:
                      try:
                        yield rsetReply

                      except UnboundLocaError:
                        pass

                      try:
                        yield mailReply

                        reset = True

                      except smtp.reply:
                        pass

                    except smtp.reply:
                      reset = True

                    raise

                # Client only raises reply if unexpected/unsuccessful
                except smtp.reply:

                  # TODO Bounce
                  pass

              #return ...
              raise StopIteration(reset)

            raise reply

        raise (yield send(*ctx.recipient.__self__))

  listen = tcp.listen(1438, interface='localhost')
  while True:
    server((yield listen()))

@untwisted.call
class factory(http.HTTPFactory):
  class protocol(http.HTTPChannel):
    class requestFactory(http.Request):
      def process(ctx):
        try:
          qwer('/', rfc5322.addrSpec).match(ctx.path)

        except ValueError:
          ctx.setResponseCode(http.NOT_FOUND)

        else:
          ctx.write(address(ctx.path[1:]))

        ctx.finish()

reactor.listenTCP(8743, factory, interface='localhost')

reactor.run()
